import FmeServerError from "../utils/FmeServerError.js";
import log4js from "log4js";
import axios from "axios";

const logger = log4js.getLogger("service.fmeServer");

const TOKEN_NAME = "Hajkmap-session-token";
const TOKEN_EXPIRATION_TIMEOUT = 3600;

class FmeServerService {
  constructor() {
    if (process.env.FME_SERVER_ACTIVE !== "true") {
      logger.info(
        "FME_SERVER_ACTIVE is set to %o in .env. Not enabling FME-server services.",
        process.env.FME_SERVER_ACTIVE
      );
      return;
    }

    logger.trace("Initiating FmeServerService");

    if (
      process.env.FME_SERVER_USER === undefined ||
      process.env.FME_SERVER_PASSWORD === undefined ||
      process.env.FME_SERVER_BASE === undefined
    ) {
      throw new FmeServerError("Configuration missing");
    }

    // Might be unnecessary, but this let's us check against a "real" object rather
    // than checking if the key in .env is === "true".
    this._serviceActive = true;

    // An object to hold the FME-token information that we use when making requests to the FME-server.
    this._tokenInformation = {
      token: null,
      expirationDate: null,
    };
  }

  _handleServiceNotActive() {
    logger.trace(
      "Attempt to access FME-server functionality – FME-server is disabled in .env"
    );
    throw new FmeServerError(
      "FME-server service is disabled. There is no way to fetch the repositories."
    );
  }

  async _getAccessToken() {
    try {
      const response = await axios.get(
        `${process.env.FME_SERVER_BASE}/fmerest/v3/tokens/${process.env.FME_SERVER_USER}/${TOKEN_NAME}`,
        {},
        {
          auth: {
            username: process.env.FME_SERVER_USER,
            password: process.env.FME_SERVER_PASSWORD,
          },
        }
      );
      console.log("response.data: ", response.data);
      const { token, expirationDate } = response.data;
      return { token, expirationDate, error: null };
    } catch (error) {
      return { token: null, expirationDate: null, error: error.response };
    }
  }

  async _generateNewAccessToken() {
    try {
      const response = await axios.post(
        `${process.env.FME_SERVER_BASE}/fmerest/v3/tokens`,
        {
          description: `Session token used by Hajkmap. Generated by: ${process.env.FME_SERVER_USER}`,
          enabled: true,
          expirationTimeout: 3600,
          name: "Hajkmap-session-token",
          restricted: false,
          user: process.env.FME_SERVER_USER,
        },
        {
          auth: {
            username: process.env.FME_SERVER_USER,
            password: process.env.FME_SERVER_PASSWORD,
          },
        }
      );
      const { token, expirationDate } = response.data;
      return { token, expirationDate, error: null };
    } catch (error) {
      return { token: null, expirationDate: null, error: error.response };
    }
  }

  async _refreshAccessToken() {
    try {
      const response = await axios.put(
        `${process.env.FME_SERVER_BASE}/fmerest/v3/tokens/hajkmap/${TOKEN_NAME}`,
        {
          expirationTimeout: TOKEN_EXPIRATION_TIMEOUT,
        },
        {
          auth: {
            username: process.env.FME_SERVER_USER,
            password: process.env.FME_SERVER_PASSWORD,
          },
        }
      );
      console.log("response.data: ", response.data);
      const { token, expirationDate } = response.data;
      return { token, expirationDate, error: null };
    } catch (error) {
      return { token: null, expirationDate: null, error: error.response };
    }
  }

  _refreshAccessToken() {
    logger.trace(
      "Attempt to access FME-server functionality – FME-server is disabled in .env"
    );
    throw new FmeServerError(
      "FME-server service is disabled. There is no way to fetch the repositories."
    );
  }

  _getAccessTokenStatus() {
    if (!this._tokenInformation.token) {
      console.log("TOKEN_MISSING");
      return "TOKEN_MISSING";
    }
    if (new Date() > this._tokenInformation.expirationDate) {
      console.log("TOKEN_EXPIRED");
      return "TOKEN_EXPIRED";
    }
    return "TOKEN_VALID";
  }

  async _getValidAccessToken() {
    const tokenStatus = this._getAccessTokenStatus();
    switch (tokenStatus) {
      case "TOKEN_EXPIRED":
        await this._refreshAccessToken();
        const newExpiration = new Date();
        newExpiration.setSeconds(
          newExpiration.getSeconds() + TOKEN_EXPIRATION_TIMEOUT
        );
        this._tokenInformation.expirationDate = newExpiration;
        return this._tokenInformation.token;
      case "TOKEN_MISSING":
        const fetchedToken = await this._getAccessToken();
        const newTokenInformation = await this._generateNewAccessToken();
        // We might get an error when creating a new token, e.g. if the token
        // we want to create already exists, or if the server is un-reachable.
        if (newTokenInformation.error) {
          // If the status code is 409, the token we want to create already exists.
          // The token might still be valid, (and only missing from our "store" because
          // of server restarts etc.) but lets refresh it anyways. (TODO: Maybe?)
          if (newTokenInformation.error.status === 409) {
            const refreshedTokenInformation = await this._refreshAccessToken();
          }
          throw new FmeServerError(
            `Failed to generate a new token. Error: ${newTokenInformation.error.data.message}`
          );
        }
        // If no error was returned, we created a new token successfully. Let's
        // update the token-object with the new information.
        const { token, expirationDate } = newTokenInformation;
        this._tokenInformation.token = token;
        this._tokenInformation.expirationDate = expirationDate;

        // And then return a token that we know for sure is valid!
        return newTokenInformation.token;
      default:
        // If the token isn't expired or missing it must be valid, right?
        return this._tokenInformation.token;
    }
  }

  async getRepositories() {
    try {
      if (!this._serviceActive) {
        this._handleServiceNotActive();
      }
      const token = await this._getValidAccessToken();
      return { token };
    } catch (error) {
      return { error };
    }
  }
}

export default new FmeServerService();
